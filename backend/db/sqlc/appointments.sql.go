// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: appointments.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const cancelAppointment = `-- name: CancelAppointment :one
UPDATE appointments
SET status = 'cancelled'
WHERE id = $1
RETURNING id, visitor_id, host_id, appointment_date, start_time, end_time, status, qr_code, created_at
`

func (q *Queries) CancelAppointment(ctx context.Context, id int32) (Appointment, error) {
	row := q.queryRow(ctx, q.cancelAppointmentStmt, cancelAppointment, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.VisitorID,
		&i.HostID,
		&i.AppointmentDate,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.QrCode,
		&i.CreatedAt,
	)
	return i, err
}

const createAppointment = `-- name: CreateAppointment :one
WITH updated_visitor AS (
  UPDATE "users"
  SET "appointments_visited" = "appointments_visited" + 1
  WHERE "id" = $1
  RETURNING "id"
),
updated_host AS (
  UPDATE "users"
  SET "appointments_hosted" = "appointments_hosted" + 1
  WHERE "id" = $2
  RETURNING "id"
)
INSERT INTO appointments (
  visitor_id, host_id, appointment_date, start_time, end_time, status, qr_code
) 
VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, visitor_id, host_id, appointment_date, start_time, end_time, status, qr_code, created_at
`

type CreateAppointmentParams struct {
	VisitorID       int32          `json:"visitor_id"`
	HostID          int32          `json:"host_id"`
	AppointmentDate time.Time      `json:"appointment_date"`
	StartTime       time.Time      `json:"start_time"`
	EndTime         time.Time      `json:"end_time"`
	Status          sql.NullString `json:"status"`
	QrCode          sql.NullString `json:"qr_code"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.queryRow(ctx, q.createAppointmentStmt, createAppointment,
		arg.VisitorID,
		arg.HostID,
		arg.AppointmentDate,
		arg.StartTime,
		arg.EndTime,
		arg.Status,
		arg.QrCode,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.VisitorID,
		&i.HostID,
		&i.AppointmentDate,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.QrCode,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM appointments
WHERE id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteAppointmentStmt, deleteAppointment, id)
	return err
}

const getAppointmentByID = `-- name: GetAppointmentByID :one
SELECT id, visitor_id, host_id, appointment_date, start_time, end_time, status, qr_code, created_at FROM appointments
WHERE id = $1
`

func (q *Queries) GetAppointmentByID(ctx context.Context, id int32) (Appointment, error) {
	row := q.queryRow(ctx, q.getAppointmentByIDStmt, getAppointmentByID, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.VisitorID,
		&i.HostID,
		&i.AppointmentDate,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.QrCode,
		&i.CreatedAt,
	)
	return i, err
}

const getAppointmentByQRCode = `-- name: GetAppointmentByQRCode :one
SELECT 
  a.id, a.visitor_id, a.host_id, a.appointment_date, a.start_time, a.end_time, a.status, a.qr_code, a.created_at,
  host.first_name || ' ' || host.last_name AS host_name,
  visitor.first_name || ' ' || visitor.last_name AS visitor_name
FROM appointments a
JOIN users host ON a.host_id = host.id
JOIN users visitor ON a.visitor_id = visitor.id
WHERE a.qr_code = $1
LIMIT 1
`

type GetAppointmentByQRCodeRow struct {
	ID              int32          `json:"id"`
	VisitorID       int32          `json:"visitor_id"`
	HostID          int32          `json:"host_id"`
	AppointmentDate time.Time      `json:"appointment_date"`
	StartTime       time.Time      `json:"start_time"`
	EndTime         time.Time      `json:"end_time"`
	Status          sql.NullString `json:"status"`
	QrCode          sql.NullString `json:"qr_code"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	HostName        interface{}    `json:"host_name"`
	VisitorName     interface{}    `json:"visitor_name"`
}

func (q *Queries) GetAppointmentByQRCode(ctx context.Context, qrCode sql.NullString) (GetAppointmentByQRCodeRow, error) {
	row := q.queryRow(ctx, q.getAppointmentByQRCodeStmt, getAppointmentByQRCode, qrCode)
	var i GetAppointmentByQRCodeRow
	err := row.Scan(
		&i.ID,
		&i.VisitorID,
		&i.HostID,
		&i.AppointmentDate,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.QrCode,
		&i.CreatedAt,
		&i.HostName,
		&i.VisitorName,
	)
	return i, err
}

const getUserAppointmentStats = `-- name: GetUserAppointmentStats :one
SELECT 
  u.appointments_hosted,
  u.appointments_visited,
  COUNT(a.id) AS pending_appointments
FROM users u
LEFT JOIN appointments a ON u.id = a.host_id AND a.status = 'pending'
WHERE u.id = $1
GROUP BY u.appointments_hosted, u.appointments_visited
`

type GetUserAppointmentStatsRow struct {
	AppointmentsHosted  sql.NullInt32 `json:"appointments_hosted"`
	AppointmentsVisited sql.NullInt32 `json:"appointments_visited"`
	PendingAppointments int64         `json:"pending_appointments"`
}

func (q *Queries) GetUserAppointmentStats(ctx context.Context, id int32) (GetUserAppointmentStatsRow, error) {
	row := q.queryRow(ctx, q.getUserAppointmentStatsStmt, getUserAppointmentStats, id)
	var i GetUserAppointmentStatsRow
	err := row.Scan(&i.AppointmentsHosted, &i.AppointmentsVisited, &i.PendingAppointments)
	return i, err
}

const listAppointmentsByDate = `-- name: ListAppointmentsByDate :many
SELECT 
    a.id, a.visitor_id, a.host_id, a.appointment_date, a.start_time, a.end_time, a.status, a.qr_code, a.created_at,
    host.first_name || ' ' || host.last_name AS host_name,
    visitor.first_name || ' ' || visitor.last_name AS visitor_name
FROM appointments a
JOIN users host ON a.host_id = host.id
JOIN users visitor ON a.visitor_id = visitor.id
WHERE a.appointment_date = $1
ORDER BY a.start_time
`

type ListAppointmentsByDateRow struct {
	ID              int32          `json:"id"`
	VisitorID       int32          `json:"visitor_id"`
	HostID          int32          `json:"host_id"`
	AppointmentDate time.Time      `json:"appointment_date"`
	StartTime       time.Time      `json:"start_time"`
	EndTime         time.Time      `json:"end_time"`
	Status          sql.NullString `json:"status"`
	QrCode          sql.NullString `json:"qr_code"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	HostName        interface{}    `json:"host_name"`
	VisitorName     interface{}    `json:"visitor_name"`
}

func (q *Queries) ListAppointmentsByDate(ctx context.Context, appointmentDate time.Time) ([]ListAppointmentsByDateRow, error) {
	rows, err := q.query(ctx, q.listAppointmentsByDateStmt, listAppointmentsByDate, appointmentDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByDateRow{}
	for rows.Next() {
		var i ListAppointmentsByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.VisitorID,
			&i.HostID,
			&i.AppointmentDate,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.QrCode,
			&i.CreatedAt,
			&i.HostName,
			&i.VisitorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByHost = `-- name: ListAppointmentsByHost :many
SELECT 
  a.id, a.visitor_id, a.host_id, a.appointment_date, a.start_time, a.end_time, a.status, a.qr_code, a.created_at, 
  u.first_name || ' ' || u.last_name AS visitor_name,
  u.role AS role
FROM appointments a
JOIN users u ON a.visitor_id = u.id
WHERE a.host_id = $1
ORDER BY a.appointment_date DESC
`

type ListAppointmentsByHostRow struct {
	ID              int32          `json:"id"`
	VisitorID       int32          `json:"visitor_id"`
	HostID          int32          `json:"host_id"`
	AppointmentDate time.Time      `json:"appointment_date"`
	StartTime       time.Time      `json:"start_time"`
	EndTime         time.Time      `json:"end_time"`
	Status          sql.NullString `json:"status"`
	QrCode          sql.NullString `json:"qr_code"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	VisitorName     interface{}    `json:"visitor_name"`
	Role            sql.NullString `json:"role"`
}

func (q *Queries) ListAppointmentsByHost(ctx context.Context, hostID int32) ([]ListAppointmentsByHostRow, error) {
	rows, err := q.query(ctx, q.listAppointmentsByHostStmt, listAppointmentsByHost, hostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByHostRow{}
	for rows.Next() {
		var i ListAppointmentsByHostRow
		if err := rows.Scan(
			&i.ID,
			&i.VisitorID,
			&i.HostID,
			&i.AppointmentDate,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.QrCode,
			&i.CreatedAt,
			&i.VisitorName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByVisitor = `-- name: ListAppointmentsByVisitor :many
SELECT 
  a.id, a.visitor_id, a.host_id, a.appointment_date, a.start_time, a.end_time, a.status, a.qr_code, a.created_at, 
  u.first_name || ' ' || u.last_name AS host_name,
  u.role AS role
FROM appointments a
JOIN users u ON a.host_id = u.id
WHERE a.visitor_id = $1
ORDER BY a.appointment_date DESC
`

type ListAppointmentsByVisitorRow struct {
	ID              int32          `json:"id"`
	VisitorID       int32          `json:"visitor_id"`
	HostID          int32          `json:"host_id"`
	AppointmentDate time.Time      `json:"appointment_date"`
	StartTime       time.Time      `json:"start_time"`
	EndTime         time.Time      `json:"end_time"`
	Status          sql.NullString `json:"status"`
	QrCode          sql.NullString `json:"qr_code"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	HostName        interface{}    `json:"host_name"`
	Role            sql.NullString `json:"role"`
}

func (q *Queries) ListAppointmentsByVisitor(ctx context.Context, visitorID int32) ([]ListAppointmentsByVisitorRow, error) {
	rows, err := q.query(ctx, q.listAppointmentsByVisitorStmt, listAppointmentsByVisitor, visitorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAppointmentsByVisitorRow{}
	for rows.Next() {
		var i ListAppointmentsByVisitorRow
		if err := rows.Scan(
			&i.ID,
			&i.VisitorID,
			&i.HostID,
			&i.AppointmentDate,
			&i.StartTime,
			&i.EndTime,
			&i.Status,
			&i.QrCode,
			&i.CreatedAt,
			&i.HostName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointments
SET status = $2
WHERE id = $1
RETURNING id, visitor_id, host_id, appointment_date, start_time, end_time, status, qr_code, created_at
`

type UpdateAppointmentStatusParams struct {
	ID     int32          `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (Appointment, error) {
	row := q.queryRow(ctx, q.updateAppointmentStatusStmt, updateAppointmentStatus, arg.ID, arg.Status)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.VisitorID,
		&i.HostID,
		&i.AppointmentDate,
		&i.StartTime,
		&i.EndTime,
		&i.Status,
		&i.QrCode,
		&i.CreatedAt,
	)
	return i, err
}
